<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
    <script src="bower_components/underscore/underscore-min.js"></script>
    <script src="snap.svg.js"></script>
</head>
<body>
<style>
    #divContainer {
        display: flex;
        flex-flow: row wrap;
        align-items: stretch;
        justify-content: space-around;
    }

    .svgContainer {
        background-color: #EEEEEE;
    }

    .svgTest {
        height: 500px;
        width: 500px;
        border: 2px solid;
    }

</style>
<div id="divContainer">
    <div>
        <svg id="svg3" class="svgTest">
            <defs>
                <linearGradient id="svg3_SVGID_1_" gradientUnits="userSpaceOnUse" x1="736.1689" y1="46.1816"
                                x2="634.331"
                                y2="26.082"
                                gradientTransform="matrix(0.6113 -0.7914 -0.7914 -0.6113 -349.3604 632.0596)">
                    <stop offset="0.0182" style="stop-color:#8CD1FA"/>
                    <stop offset="0.192" style="stop-color:#88CFF8"/>
                    <stop offset="0.3666" style="stop-color:#7CCAF3"/>
                    <stop offset="0.5416" style="stop-color:#68C0EA"/>
                    <stop offset="0.7169" style="stop-color:#4CB4DD"/>
                    <stop offset="0.8909" style="stop-color:#28A3CD"/>
                    <stop offset="1" style="stop-color:#0D97C1"/>
                </linearGradient>
                <path id="svg3_arrow_transformRate" fill="url(#svg3_SVGID_1_)" d="M63.827,61.182c-4.61,11.659-15.718,18.868-27.556,19.103l-1.027,6.002l-8.769-12.395
				l12.391-8.771l-0.964,5.632c7.5-0.809,14.311-5.668,17.22-13.176c0-0.003,0.003-0.008,0.005-0.017
				c4.136-10.7-1.198-22.771-11.898-26.919c-0.046-0.017-0.092-0.028-0.139-0.044l5.337-3.782l-4.059-5.735
				c0.759,0.228,1.515,0.481,2.266,0.773c15.552,6.027,23.3,23.581,17.275,39.13C63.883,61.05,63.854,61.115,63.827,61.182z"/>
                <!--<g id="arrowGDefs">-->
                <!--<g>-->
                <!--<path d="M5,5h6v6,h3l-6,6l-6,-6h3Z" fill="#6699FF" opacity="0">-->
                <!--<animate attributeName="opacity" from="0" to="0.2" begin="0s" dur="1s" repeatCount="indefinite" />-->
                <!--</path>-->
                <!--<path d="M5,20h6v6,h3l-6,6l-6,-6h3Z" fill="#6699FF" opacity="0.2">-->
                <!--<animate attributeName="opacity" from="0.2" to="1" begin="0s" dur="1s" repeatCount="indefinite" />-->
                <!--</path>-->
                <!--<path d="M5,35h6v6,h3l-6,6l-6,-6h3Z" fill="#6699FF" opacity="1">-->
                <!--</path>-->
                <!--<path d="M5,50h6v6,h3l-6,6l-6,-6h3Z" fill="#6699FF" opacity="1">-->
                <!--<animate attributeName="opacity" from="1" to="0.2" begin="0s" dur="1s" repeatCount="indefinite" />-->
                <!--</path>-->
                <!--<path d="M5,65h6v6,h3l-6,6l-6,-6h3Z" fill="#6699FF" opacity="0.2">-->
                <!--<animate attributeName="opacity" from="0.2" to="0" begin="0s" dur="1s" repeatCount="indefinite" />-->
                <!--</path>-->
                <!--</g>-->
                <!--<animateTransform attributeName="transform" type="translate" from="0,0" to="0,15" begin="0s" dur="1s" repeatCount="indefinite" />-->
                <!--</g>-->
            </defs>
        </svg>

    </div>
</div>
<script>

    var svg = Snap("#svg3");
    var animDuration_default = 500;                  // 默认动画时长
    //    var easing_channelPath = mina.easeinout;         // 分渠道图形渐变函数
    var easing_channelPath = mina.elastic;         // 分渠道图形渐变函数
    var opacity_default = 1;

    // 左杯壁 左曲线
    var leftBorderLPath = svg.paper.path("M20,50Q90,200,90,480").toDefs();
    /*.attr({
     fill: 'none',
     stroke: "#999999",
     strokeWidth: 2
     });*/

    // 左杯壁 右曲线（从下到上绘图）
    var leftBorderRPath = svg.paper.path("M110,480Q110,200,40,50").toDefs();

    // 右杯壁 左曲线
    var rightBorderLPath = svg.paper.path("M360,50Q290,200,290,480").toDefs();

    // 右杯壁 右曲线（从下到上绘图）
    var rightBorderRPath = svg.paper.path("M310,480Q310,200,380,50").toDefs();

    // 获取杯壁4条曲线的长度
    var len1 = leftBorderLPath.getTotalLength();
    var len2 = leftBorderRPath.getTotalLength();
    var len3 = rightBorderLPath.getTotalLength();
    var len4 = rightBorderRPath.getTotalLength();

    // 向下转化 箭头 & 动画，封装到 defs 中
    var arrowGapHeight = 15;                             // 箭头的间隔
    var arrowColor = '#6699FF';                         // 箭头的填充颜色
    // 总高度 12，总宽度 12
    var arrowPath = svg.paper.path("M5,5h6v6,h3l-6,6l-6,-6h3Z").attr({
        fill: arrowColor,
        opacity: 0
    });
    var arrowPath2 = svg.paper.path("M5,20h6v6,h3l-6,6l-6,-6h3Z").attr({
        fill: arrowColor,
        opacity: 0.2
    });
    var arrowPath3 = svg.paper.path("M5,35h6v6,h3l-6,6l-6,-6h3Z").attr({
        fill: arrowColor
    });
    var arrowPath4 = svg.paper.path("M5,50h6v6,h3l-6,6l-6,-6h3Z").attr({
        fill: arrowColor
    });
    var arrowPath5 = svg.paper.path("M5,65h6v6,h3l-6,6l-6,-6h3Z").attr({
        fill: arrowColor,
        opacity: 0.2
    });
    // 加入到defs中
    var arrowG = svg.paper.g(arrowPath, arrowPath2, arrowPath3, arrowPath4, arrowPath5)
            .attr({id: 'arrowGDefs', 'pointer-events': 'none'}).toDefs();

    arrowPath = null;
    arrowPath2 = null;
    arrowPath3 = null;
    arrowPath4 = null;
    arrowPath5 = null;

    // NOTE: 使用SMIL会节省一点CPU资源，但是兼容器太差，IE11不支持。
    //            var arrowG = Snap('#arrowGDefs');

    // 重用，减少memory leak和节省cpu

    var arrowGtrForm = new Snap.Matrix().translate(0, 0).toTransformString();
    var arrowGtrTo = new Snap.Matrix().translate(0, arrowGapHeight).toTransformString();

    // 5个箭头的动画，包括位移和透明度的变化
    function arrowAnimation() {
        arrowG[0].animate({
            opacity: 0.2
        }, 1000, null, function () {
            arrowG[0].attr({
                opacity: 0
            });
        });
        arrowG[1].animate({
            opacity: 1
        }, 1000, null, function () {
            arrowG[1].attr({
                opacity: 0.2
            });
        });
        arrowG[3].animate({
            opacity: 0.2
        }, 1000, null, function () {
            arrowG[3].attr({
                opacity: 1
            });
        });
        arrowG[4].animate({
            opacity: 0
        }, 1000, null, function () {
            arrowG[4].attr({
                opacity: 0.2
            });
        });
        // NOTE: defs中不使用transform，动画不会引用到各个use中。。。。大坑，原因未知
        arrowG.animate({transform: arrowGtrTo}
                , 1000, null, function () {
                    arrowG.attr({transform: arrowGtrForm});
                });
    }
    // 执行动画，间隔时间长一点点，保证动画衔接得流畅，不然箭头的动画还没完成，下一个循环就开始了。
    var token_interval_arrowG;

    token_interval_arrowG = setInterval(function () {
        arrowAnimation();
    }, 1050);

    // 绘制漏斗区域的图形

    var funnelHeight = 430;                     // 漏斗区域总高度
    var layer1Height = 70;                       // 第二层高度比例
    var layer2Height = 130;                      // 第二层高度比例
    var layer3Height = 200;                      // 第三层高度比例
    var layerGapHeight = 15;                     // 每层相隔的高度
    var layerGapHeightRate = layerGapHeight / funnelHeight;

    // 存放各层杯壁内部的四个坐标
    var borderCoordinate = [];

    // 得出各层杯壁的曲线Path和四个点，用来绘制杯壁，并保存到borderCoordinate
    // 第一层——左杯壁
    var s3L1LBorderLPathStr = leftBorderLPath.getSubpath(0, layer1Height / funnelHeight * len1);
    var s3L1LBorderLPathPoints = Snap.parsePathString(s3L1LBorderLPathStr);
    var s3L1LBorderPoint1 = s3L1LBorderLPathPoints[0][1] + ','
            + s3L1LBorderLPathPoints[0][2];
    var s3L1LBorderPoint4 = s3L1LBorderLPathPoints[1][s3L1LBorderLPathPoints[1].length - 2] + ','
            + s3L1LBorderLPathPoints[1][s3L1LBorderLPathPoints[1].length - 1];

    var s3L1LBorderRPathStr = leftBorderRPath.getSubpath((1 - layer1Height / funnelHeight) * len2, len2);
    var s3L1LBorderRPathPoints = Snap.parsePathString(s3L1LBorderRPathStr);
    var s3L1LBorderPoint3 = s3L1LBorderRPathPoints[0][1] + ','
            + s3L1LBorderRPathPoints[0][2];
    var s3L1LBorderPoint2 = s3L1LBorderRPathPoints[1][s3L1LBorderRPathPoints[1].length - 2] + ','
            + s3L1LBorderRPathPoints[1][s3L1LBorderRPathPoints[1].length - 1];

    // 第一层——右杯壁
    var s3L1RBorderLPathStr = rightBorderLPath.getSubpath(0, layer1Height / funnelHeight * len3);
    var s3L1RBorderLPathPoints = Snap.parsePathString(s3L1RBorderLPathStr);
    var s3L1RBorderPoint1 = s3L1RBorderLPathPoints[0][1] + ','
            + s3L1RBorderLPathPoints[0][2];
    var s3L1RBorderPoint4 = s3L1RBorderLPathPoints[1][s3L1RBorderLPathPoints[1].length - 2] + ','
            + s3L1RBorderLPathPoints[1][s3L1RBorderLPathPoints[1].length - 1];

    var s3L1RBorderRPathStr = rightBorderRPath.getSubpath((1 - layer1Height / funnelHeight) * len4, len4);
    var s3L1RBorderRPathPoints = Snap.parsePathString(s3L1RBorderRPathStr);
    var s3L1RBorderPoint3 = s3L1RBorderRPathPoints[0][1] + ','
            + s3L1LBorderRPathPoints[0][2];
    var s3L1RBorderPoint2 = s3L1RBorderRPathPoints[1][s3L1RBorderRPathPoints[1].length - 2] + ','
            + s3L1RBorderRPathPoints[1][s3L1RBorderRPathPoints[1].length - 1];
    // 保存杯壁内部point
    borderCoordinate.push({
        layer: 1,
        leftPathStr: s3L1LBorderRPathStr,
        rightPathStr: s3L1RBorderLPathStr,
        leftTopX: s3L1LBorderRPathPoints[1][s3L1LBorderRPathPoints[1].length - 2],
        leftTopY: s3L1LBorderRPathPoints[1][s3L1LBorderRPathPoints[1].length - 1],
        leftBottomX: s3L1LBorderRPathPoints[0][1],
        leftBottomY: s3L1LBorderRPathPoints[0][2],
        rightTopX: s3L1RBorderLPathPoints[0][1],
        rightTopY: s3L1RBorderLPathPoints[0][2],
        rightBottomX: s3L1RBorderLPathPoints[1][s3L1RBorderLPathPoints[1].length - 2],
        rightBottomY: s3L1RBorderLPathPoints[1][s3L1RBorderLPathPoints[1].length - 1]
    });

    // 第二层——左杯壁
    var s3L2LBorderLPathStr = leftBorderLPath.getSubpath((layer1Height + layerGapHeight) / funnelHeight * len1, (layer1Height + layerGapHeight + layer2Height) / funnelHeight * len1);
    var s3L2LBorderLPathPoints = Snap.parsePathString(s3L2LBorderLPathStr);
    var s3L2LBorderPoint1 = s3L2LBorderLPathPoints[0][1] + ','
            + s3L2LBorderLPathPoints[0][2];
    var s3L2LBorderPoint4 = s3L2LBorderLPathPoints[1][s3L2LBorderLPathPoints[1].length - 2] + ','
            + s3L2LBorderLPathPoints[1][s3L2LBorderLPathPoints[1].length - 1];

    var s3L2LBorderRPathStr = leftBorderRPath.getSubpath((1 - (layer1Height + layerGapHeight + layer2Height) / funnelHeight) * len2, (1 - (layer1Height + layerGapHeight) / funnelHeight) * len2);
    var s3L2LBorderRPathPoints = Snap.parsePathString(s3L2LBorderRPathStr);
    var s3L2LBorderPoint3 = s3L2LBorderRPathPoints[0][1] + ','
            + s3L2LBorderRPathPoints[0][2];
    var s3L2LBorderPoint2 = s3L2LBorderRPathPoints[1][s3L2LBorderRPathPoints[1].length - 2] + ','
            + s3L2LBorderRPathPoints[1][s3L2LBorderRPathPoints[1].length - 1];

    // 第二层——右杯壁
    var s3L2RBorderLPathStr = rightBorderLPath.getSubpath((layer1Height + layerGapHeight) / funnelHeight * len3, (layer1Height + layerGapHeight + layer2Height) / funnelHeight * len3);
    var s3L2RBorderLPathPoints = Snap.parsePathString(s3L2RBorderLPathStr);
    var s3L2RBorderPoint1 = s3L2RBorderLPathPoints[0][1] + ','
            + s3L2RBorderLPathPoints[0][2];
    var s3L2RBorderPoint4 = s3L2RBorderLPathPoints[1][s3L2RBorderLPathPoints[1].length - 2] + ','
            + s3L2RBorderLPathPoints[1][s3L2RBorderLPathPoints[1].length - 1];

    var s3L2RBorderRPathStr = rightBorderRPath.getSubpath((1 - (layer1Height + layerGapHeight + layer2Height) / funnelHeight) * len4, (1 - (layer1Height + layerGapHeight) / funnelHeight) * len4);
    var s3L2RBorderRPathPoints = Snap.parsePathString(s3L2RBorderRPathStr);
    var s3L2RBorderPoint3 = s3L2RBorderRPathPoints[0][1] + ','
            + s3L2RBorderRPathPoints[0][2];
    var s3L2RBorderPoint2 = s3L2RBorderRPathPoints[1][s3L2RBorderRPathPoints[1].length - 2] + ','
            + s3L2RBorderRPathPoints[1][s3L2RBorderRPathPoints[1].length - 1];

    // 保存杯壁内部point
    borderCoordinate.push({
        layer: 2,
        leftPathStr: s3L2LBorderRPathStr,
        rightPathStr: s3L2RBorderLPathStr,
        leftTopX: s3L2LBorderRPathPoints[1][s3L2LBorderRPathPoints[1].length - 2],
        leftTopY: s3L2LBorderRPathPoints[1][s3L2LBorderRPathPoints[1].length - 1],
        leftBottomX: s3L2LBorderRPathPoints[0][1],
        leftBottomY: s3L2LBorderRPathPoints[0][2],
        rightTopX: s3L2RBorderLPathPoints[0][1],
        rightTopY: s3L2RBorderLPathPoints[0][2],
        rightBottomX: s3L2RBorderLPathPoints[1][s3L2RBorderLPathPoints[1].length - 2],
        rightBottomY: s3L2RBorderLPathPoints[1][s3L2RBorderLPathPoints[1].length - 1]
    });

    // 第三层——左杯壁
    var s3L3LBorderLPathStr = leftBorderLPath.getSubpath((layer1Height + layerGapHeight + layer2Height + layerGapHeight) / funnelHeight * len1, len1);
    var s3L3LBorderLPathPoints = Snap.parsePathString(s3L3LBorderLPathStr);
    var s3L3LBorderPoint1 = s3L3LBorderLPathPoints[0][1] + ','
            + s3L3LBorderLPathPoints[0][2];
    var s3L3LBorderPoint4 = s3L3LBorderLPathPoints[1][s3L3LBorderLPathPoints[1].length - 2] + ','
            + s3L3LBorderLPathPoints[1][s3L3LBorderLPathPoints[1].length - 1];

    var s3L3LBorderRPathStr = leftBorderRPath.getSubpath(0, (1 - (layer1Height + layerGapHeight + layer2Height + layerGapHeight) / funnelHeight) * len2);
    var s3L3LBorderRPathPoints = Snap.parsePathString(s3L3LBorderRPathStr);
    var s3L3LBorderPoint3 = s3L3LBorderRPathPoints[0][1] + ','
            + s3L3LBorderRPathPoints[0][2];
    var s3L3LBorderPoint2 = s3L3LBorderRPathPoints[1][s3L3LBorderRPathPoints[1].length - 2] + ','
            + s3L3LBorderRPathPoints[1][s3L3LBorderRPathPoints[1].length - 1];

    // 第三层——右杯壁
    var s3L3RBorderLPathStr = rightBorderLPath.getSubpath((layer1Height + layerGapHeight + layer2Height + layerGapHeight) / funnelHeight * len3, len3);
    var s3L3RBorderLPathPoints = Snap.parsePathString(s3L3RBorderLPathStr);
    var s3L3RBorderPoint1 = s3L3RBorderLPathPoints[0][1] + ','
            + s3L3RBorderLPathPoints[0][2];
    var s3L3RBorderPoint4 = s3L3RBorderLPathPoints[1][s3L3RBorderLPathPoints[1].length - 2] + ','
            + s3L3RBorderLPathPoints[1][s3L3RBorderLPathPoints[1].length - 1];

    var s3L3RBorderRPathStr = rightBorderRPath.getSubpath(0, (1 - (layer1Height + layerGapHeight + layer2Height + layerGapHeight) / funnelHeight) * len4);
    var s3L3RBorderRPathPoints = Snap.parsePathString(s3L3RBorderRPathStr);
    var s3L3RBorderPoint3 = s3L3RBorderRPathPoints[0][1] + ','
            + s3L3RBorderRPathPoints[0][2];
    var s3L3RBorderPoint2 = s3L3RBorderRPathPoints[1][s3L3RBorderRPathPoints[1].length - 2] + ','
            + s3L3RBorderRPathPoints[1][s3L3RBorderRPathPoints[1].length - 1];

    // 保存杯壁内部point
    borderCoordinate.push({
        layer: 3,
        leftPathStr: s3L3LBorderRPathStr,
        rightPathStr: s3L3RBorderLPathStr,
        leftTopX: s3L3LBorderRPathPoints[1][s3L3LBorderRPathPoints[1].length - 2],
        leftTopY: s3L3LBorderRPathPoints[1][s3L3LBorderRPathPoints[1].length - 1],
        leftBottomX: s3L3LBorderRPathPoints[0][1],
        leftBottomY: s3L3LBorderRPathPoints[0][2],
        rightTopX: s3L3RBorderLPathPoints[0][1],
        rightTopY: s3L3RBorderLPathPoints[0][2],
        rightBottomX: s3L3RBorderLPathPoints[1][s3L3RBorderLPathPoints[1].length - 2],
        rightBottomY: s3L3RBorderLPathPoints[1][s3L3RBorderLPathPoints[1].length - 1]
    });


    /*
     *********************************** 设置一些常量 begin ************************************
     */
    var channelGapLength = 5;            // 各渠道图形之间的间隙

    var colorBorder = '#999999';        // 杯壁颜色
    var colorL1Default = '#FFFF99';     // 第一层默认颜色
    var colorL2Default = '#99FF99';     // 第二层默认颜色
    var colorL3Default = '#66CCFF';     // 第三层默认颜色

    var colorsL1Active = ['#66CCFF', '#99FF99', '#FFFF99'];    // 第一层动画状态下颜色数组
    var colorsL2Active = ['#66CCFF', '#99FF99', '#FFFF99'];    // 第二层动画状态下颜色数组
    var colorsL3Active = ['#66CCFF', '#99FF99', '#FFFF99'];    // 第三层动画状态下颜色数组

    // 字体相关

    var font_fill_value = '#6699FF';                // 针对数值text的颜色，如“80%”
    var font_fill_text = '#aaa';                          // 针对文字说明text的颜色，如“转化”
//    var font_fill_text = 'white';                          // 针对文字说明text的颜色，如“转化”
    var font_fill_layerConversion_text = '#aaa';                          // 针对文字说明text的颜色，如“转化”

    var font_weight_normal = '600';
    var font_weight_value = '700';

    var font_size_normal = '13';
    var font_size_channelValue = '18';

    var font_size_channelTransformValue = '16';


    var flag_App = true;
    var flag_WeiXin = true;
    var flag_Network = true;


    /*
     *********************************** 设置一些常量 end ************************************
     */


    // 绘制杯壁 begin

    // 杯壁左1
    var pathLeftBorder1 = svg.paper.path(s3L1LBorderLPathStr + "L" + s3L1LBorderPoint3 + s3L1LBorderRPathStr + "L" + s3L1LBorderPoint1).attr({
        fill: colorBorder
    });

    // 杯壁左2
    var pathLeftBorder2 = svg.paper.path(s3L2LBorderLPathStr + "L" + s3L2LBorderPoint3 + s3L2LBorderRPathStr + "L" + s3L2LBorderPoint1).attr({
        fill: colorBorder
    });

    // 杯壁左3
    var pathLeftBorder3 = svg.paper.path(s3L3LBorderLPathStr + "L" + s3L3LBorderPoint3 + s3L3LBorderRPathStr + "L" + s3L3LBorderPoint1).attr({
        fill: colorBorder
    });

    // 杯壁右1
    var pathRightBorder1 = svg.paper.path(s3L1RBorderLPathStr + "L" + s3L1RBorderPoint3 + s3L1RBorderRPathStr + "L" + s3L1RBorderPoint1).attr({
        fill: colorBorder
    });

    // 杯壁右2
    var pathRightBorder2 = svg.paper.path(s3L2RBorderLPathStr + "L" + s3L2RBorderPoint3 + s3L2RBorderRPathStr + "L" + s3L2RBorderPoint1).attr({
        fill: colorBorder
    });

    // 杯壁右3
    var pathRightBorder3 = svg.paper.path(s3L3RBorderLPathStr + "L" + s3L3RBorderPoint3 + s3L3RBorderRPathStr + "L" + s3L3RBorderPoint1).attr({
        fill: colorBorder
    });
    // 绘制杯壁 end


    // 填充各渠道图形 begin

    var channelsData = [
        {
            index: '0',
            appRate: 0.3,
            weiXinRate: 0.45,
            networkRate: 0.25,
            appConversionRate: '50%',
            weiXinConversionRate: '20%',
            networkConversionRate: '40%',
            conversionRate: '88%',
            to10086Rate: '12%'
        },
        {
            index: '1',
            appRate: 0.25,
            weiXinRate: 0.4,
            networkRate: 0.35,
            appConversionRate: '80%',
            weiXinConversionRate: '30%',
            networkConversionRate: '20%',
            conversionRate: '68%',
            to10086Rate: '15%'
        },
        {
            index: '2',
            appRate: 0.35,
            weiXinRate: 0.45,
            networkRate: 0.2,
            appConversionRate: '',
            weiXinConversionRate: '',
            networkConversionRate: '',
            conversionRate: '',
            to10086Rate: ''
        }
    ];

    var infoRect_channelTransform = svg.paper.rect(0, 0, 45, 38, 5, 5).attr({
        fill: '#FFFFFF',
        opacity: 0.95
    }).toDefs();


    var layer1Paths_arr = [];
    var layer2Paths_arr = [];
    var layer3Paths_arr = [];

    // 向下转化部分，需要重新append一次，不然会被挡住
    var funnelIndexConversionG = svg.g();

    /*
     ****************************  动画分组   begin     ***************************************
     */
    // 层次向下转化动画分组
    var layer1AnimSet = Snap.set();                        // 第一层
    var layer2AnimSet = Snap.set();                        // 第二层
    var layer3AnimSet = Snap.set();                        // 第三层

    // 分渠道触发动画的元素集合
    var channel1HoverElementSet = Snap.set();                      // APP 分渠道
    var channel2HoverElementSet = Snap.set();                      // 微信 分渠道
    var channel3HoverElementSet = Snap.set();                      // 网络 分渠道
    // 分渠道执行动画的元素集合
    var channel1AnimSet = Snap.set();                      // APP 分渠道
    var channel2AnimSet = Snap.set();                      // 微信 分渠道
    var channel3AnimSet = Snap.set();                      // 网络 分渠道
    /*
     ****************************  动画分组   end     ***************************************
     */


    /**
     * 创建一层的分渠道图形，并在动画分组中添加对应的element
     * 参数：指标数据，该层次的动画分区，该层次的分渠道path element，
     * 该层次默认颜色，该层次选中时的颜色数组，初始化opacity，转化区域的Y坐标
     */
    function createChannelArea(indexData, layerAnimSet, layerPaths_arr, defaultColor, activeColors, opacity, conversionArea_Y) {
//        分渠道图形 path
//        a.path的width、height、中心点
//        b.path是该层第几个，绘制的方式（第一个、中间、最后一个、第一且是最后一个）
//	      c.分渠道path之间的间隙
//        d.是否创建和显示
//        e.变宽
        var appPath;
        var appPathText;
        var appPathCenterPoint;              // 中心点
        var appArrowG;
        var appRateTextRect;
        var appRateText1;
        var appRateText2;
        var appWidth = 0;
        var appBottomWidth = 0;

        var weiXinPath;
        var weiXinPathText;
        var weiXinPathCenterPoint;              // 中心点
        var weiXinArrowG;
        var weiXinRateTextRect;
        var weiXinRateText1;
        var weiXinRateText2;
        var weiXinWidth = 0;
        var weiXinBottomWidth = 0;

        var networkPath;
        var networkPathText;
        var networkPathCenterPoint;              // 中心点
        var networkArrowG;
        var networkRateTextRect;
        var networkRateText1;
        var networkRateText2;
        var networkWidth = 0;
        var networkBottomWidth = 0;

        var appRate = indexData.appRate;
        var weiXinRate = indexData.weiXinRate;
        var networkRate = indexData.networkRate;
        var appConversionRate = indexData.appConversionRate;
        var weiXinConversionRate = indexData.weiXinConversionRate;
        var networkConversionRate = indexData.networkConversionRate;

        // 如果控制了分渠道的数量，要计算新的总占比和各分渠道占比
        var newTotal = 0;


        // 检查有几个分渠道是否有数据，如果flag为false，不生成改分渠道的element，也不执行动画
        var channelCount = 0;
        if (appRate > 0 && flag_App) {
            channelCount++;
            newTotal += appRate;
        }
        if (weiXinRate > 0 && flag_WeiXin) {
            channelCount++;
            newTotal += weiXinRate;
        }
        if (networkRate > 0 && flag_Network) {
            channelCount++;
            newTotal += networkRate;
        }

        // 到分渠道的数量改变时，分渠道显示的数值（占比）也会改变
        appRate = appRate / newTotal;
        weiXinRate = weiXinRate / newTotal;
        networkRate = networkRate / newTotal;

        // 计算每层杯壁内侧左右两侧的距离，已减去可能出现的间隔
        var layerWidth = borderCoordinate[indexData.index].rightTopX - borderCoordinate[indexData.index].leftTopX
                - channelGapLength * (channelCount - 1);
        var layerBottomWidth = borderCoordinate[indexData.index].rightBottomX - borderCoordinate[indexData.index].leftBottomX
                - channelGapLength * (channelCount - 1);
        // 该层的高度
        var layerHeight = borderCoordinate[indexData.index].rightBottomY - borderCoordinate[indexData.index].rightTopY;
        // 高层Y轴中心点
        var layerCenterY = borderCoordinate[indexData.index].rightTopY + layerHeight / 2;
        // app 图形绘制
        // TODO 如果宽度没有到达杯壁下面的点，怎么处理，
        // TODO 即 图形杯壁方向的bottomX小于杯壁内侧的bottomX（左边，右边是大于）
        // TODO 如果分渠道的宽度小，重新计算text的坐标X，
        if (appRate > 0 && flag_App) {
            appWidth = appRate * layerWidth;     // 分渠道APP图形的上方宽度
            appBottomWidth = appRate * layerBottomWidth;
            // 第一个且最后一个
            if (channelCount === 1) {
                appPath = svg.paper.path(borderCoordinate[indexData.index].leftPathStr + "l" + appWidth + ",0" + borderCoordinate[indexData.index].rightPathStr.replace("M", "L") + "Z").attr({
                    fill: defaultColor
                });
            } else {
                // 不是最后一个，右边不是弧线
                appPath = svg.paper.path(borderCoordinate[indexData.index].leftPathStr + "l" + appWidth + ",0l0," + layerHeight + "Z")
                        .attr({
                            fill: defaultColor
                        });
            }

            // 获取中心点
            appPathCenterPoint = {
                x: borderCoordinate[indexData.index].leftBottomX + appBottomWidth / 2,
                y: borderCoordinate[indexData.index].rightTopY + layerHeight / 2
            };

            // 分渠道数字和流转部分
            if (appPath) {
                layerPaths_arr.push(
                        {
                            path: appPath,
                            fill_default: defaultColor,
                            fill_anim: activeColors[0]
                        }
                );
                channel1HoverElementSet.push(appPath);

                // 图形中的文字
                appPathText = svg.paper.text(appPathCenterPoint.x - 20, layerCenterY + 10, Math.round(appRate * 100) + '%')
                        .attr({
                            'font-weight': font_weight_value,
                            'font-size': font_size_channelValue,
                            opacity: opacity,
                            'pointer-events': 'none'
                        });
                layerAnimSet.push(appPathText);
                channel1AnimSet.push(appPathText);

                if (appConversionRate) {
                    // 箭头组
                    appArrowG = arrowG.use();
                    appArrowG.attr({x: appPathCenterPoint.x - 12, y: conversionArea_Y, opacity: opacity});
                    svg.append(appArrowG);

                    appRateTextRect = infoRect_channelTransform.use();
                    appRateTextRect.attr({
                        x: appPathCenterPoint.x - 12 + 20,
                        y: conversionArea_Y + 20,
                        opacity: opacity,
                        'pointer-events': 'none'
                    });
                    svg.append(appRateTextRect);
                    appRateText1 = svg.paper.text(appPathCenterPoint.x - 12 + 20 + 5, conversionArea_Y + 20 + 17, '转化')
                            .attr({
                                'font-weight': font_weight_normal,
                                fill: font_fill_text,
//                                fill: font_fill_layerConversion_text,
                                'font-size': font_size_normal,
                                opacity: opacity,
                                'pointer-events': 'none'
                            });
                    appRateText2 = svg.paper.text(appPathCenterPoint.x - 12 + 20 + 5, conversionArea_Y + 20 + 17 + 18, appConversionRate)
                            .attr({
                                'font-size': font_size_channelTransformValue,
                                'font-weight': font_weight_value,
                                opacity: opacity,
                                'pointer-events': 'none'
                            });

                    funnelIndexConversionG.add(appArrowG, appRateTextRect, appRateText1, appRateText2);

                    layerAnimSet.push(appArrowG, appRateTextRect, appRateText1, appRateText2);
                    channel1AnimSet.push(appArrowG, appRateTextRect, appRateText1, appRateText2);
                }
            }
        }
        // weixin
        if (weiXinRate > 0 && flag_WeiXin) {
            weiXinWidth = weiXinRate * layerWidth;
            weiXinBottomWidth = weiXinRate * layerBottomWidth;
            // 第一个且最后一个
            if (channelCount === 1) {
                weiXinPath = svg.paper.path(borderCoordinate[indexData.index].leftPathStr + "l" + weiXinWidth + ",0" + borderCoordinate[indexData.index].rightPathStr.replace("M", "L") + "Z").attr({
                    fill: defaultColor
                });
                weiXinPathCenterPoint = {x: borderCoordinate[indexData.index].leftBottomX + weiXinBottomWidth / 2};
            } else if (channelCount === 3) {
                // 中间
                weiXinPath = svg.paper.path("M" + (borderCoordinate[indexData.index].leftTopX + appWidth + channelGapLength) + "," + borderCoordinate[indexData.index].leftTopY
                        + "l" + weiXinWidth + ",0l0," + layerHeight + "l" + (weiXinWidth * -1) + ",0Z").attr({
                    fill: defaultColor
                });
                weiXinPathCenterPoint = {x: borderCoordinate[indexData.index].leftBottomX + appBottomWidth + channelGapLength + weiXinBottomWidth / 2};
            } else {
                // 两个分渠道
                if (appPath) {
                    // 最后一个
                    var weiXinX = borderCoordinate[indexData.index].leftTopX + appWidth + (channelCount - 1) * 5;
                    weiXinPath = svg.paper.path(borderCoordinate[indexData.index].rightPathStr +
                            "L" + weiXinX +
                            "," + borderCoordinate[indexData.index].leftBottomY +
                            "l0," + (layerHeight * -1) + "Z").attr({
                        fill: defaultColor
                    });
                    weiXinPathCenterPoint = {x: borderCoordinate[indexData.index].rightBottomX - weiXinBottomWidth / 2};
                } else {
                    // 第一个
                    weiXinPath = svg.paper.path(borderCoordinate[indexData.index].leftPathStr + "l" + weiXinWidth + ",0l0," + layerHeight + "Z").attr({
                        fill: defaultColor
                    });
                    weiXinPathCenterPoint = {x: borderCoordinate[indexData.index].leftBottomX + weiXinBottomWidth / 2};
                }
            }

            // 分渠道数字和流转部分
            if (weiXinPath) {
                layerPaths_arr.push(
                        {
                            path: weiXinPath,
                            fill_default: defaultColor,
                            fill_anim: activeColors[1]
                        }
                );
                channel2HoverElementSet.push(weiXinPath);

                // 图形中的文字
                weiXinPathText = svg.paper.text(weiXinPathCenterPoint.x - 20, layerCenterY + 10, Math.round(weiXinRate * 100) + '%')
                        .attr({
                            'font-weight': font_weight_value,
                            'font-size': font_size_channelValue,
                            opacity: opacity,
                            'pointer-events': 'none'
                        });

                layerAnimSet.push(weiXinPathText);
                channel2AnimSet.push(weiXinPathText);

                if (weiXinConversionRate) {
                    // 箭头组
                    weiXinArrowG = arrowG.use();
                    weiXinArrowG.attr({x: weiXinPathCenterPoint.x - 12, y: conversionArea_Y, opacity: opacity});
                    svg.append(weiXinArrowG);

                    weiXinRateTextRect = infoRect_channelTransform.use();
                    weiXinRateTextRect.attr({
                        x: weiXinPathCenterPoint.x - 12 + 20,
                        y: conversionArea_Y + 20,
                        opacity: opacity,
                        'pointer-events': 'none'
                    });
                    svg.append(weiXinRateTextRect);
                    weiXinRateText1 = svg.paper.text(weiXinPathCenterPoint.x - 12 + 20 + 5, conversionArea_Y + 20 + 17, '转化')
                            .attr({
                                'font-weight': font_weight_normal,
                                fill: font_fill_text,
//                                fill: font_fill_layerConversion_text,
                                'font-size': font_size_normal,
                                opacity: opacity,
                                'pointer-events': 'none'
                            });
                    weiXinRateText2 = svg.paper.text(weiXinPathCenterPoint.x - 12 + 20 + 5, conversionArea_Y + 20 + 17 + 18, weiXinConversionRate)
                            .attr({
                                'font-size': font_size_channelTransformValue,
                                'font-weight': font_weight_value,
                                opacity: opacity,
                                'pointer-events': 'none'
                            });

                    funnelIndexConversionG.add(weiXinArrowG, weiXinRateTextRect, weiXinRateText1, weiXinRateText2);

                    layerAnimSet.push(weiXinArrowG, weiXinRateTextRect, weiXinRateText1, weiXinRateText2);
                    channel2AnimSet.push(weiXinArrowG, weiXinRateTextRect, weiXinRateText1, weiXinRateText2);
                }
            }
        }
        // network
        if (networkRate > 0 && flag_Network) {
            networkWidth = networkRate * layerWidth;
            networkBottomWidth = networkRate * layerBottomWidth;
            // 第一个且最后一个
            if (channelCount === 1) {
                networkPath = svg.paper.path(borderCoordinate[indexData.index].leftPathStr + "l" + networkWidth + ",0" + borderCoordinate[indexData.index].rightPathStr.replace("M", "L") + "Z").attr({
                    fill: defaultColor
                });
                networkPathCenterPoint = {x: borderCoordinate[indexData.index].leftTopX + networkWidth / 2};
            } else {
                // 最后一个
                var xxx1 = borderCoordinate[indexData.index].leftTopX + appWidth + weiXinWidth + (channelCount - 1) * 5;
                networkPath = svg.paper.path(borderCoordinate[indexData.index].rightPathStr +
                        "L" + xxx1 +
                        "," + borderCoordinate[indexData.index].leftBottomY +
                        "l0," + (layerHeight * -1) + "Z").attr({
                    fill: defaultColor
                });
                networkPathCenterPoint = {x: borderCoordinate[indexData.index].rightTopX - networkWidth / 2};
            }

            // 分渠道数字和流转部分
            if (networkPath) {
                layerPaths_arr.push(
                        {
                            path: networkPath,
                            fill_default: defaultColor,
                            fill_anim: activeColors[2]
                        }
                );
                channel3HoverElementSet.push(networkPath);

                // 图形中的文字
                networkPathText = svg.paper.text(networkPathCenterPoint.x - 20, layerCenterY + 10, Math.round(networkRate * 100) + '%')
                        .attr({
                            'font-weight': font_weight_value,
                            'font-size': font_size_channelValue,
                            opacity: opacity,
                            'pointer-events': 'none'
                        });
                layerAnimSet.push(networkPathText);
                channel3AnimSet.push(networkPathText);

                if (networkConversionRate) {
                    // 箭头组
                    networkArrowG = arrowG.use();
                    networkArrowG.attr({x: networkPathCenterPoint.x - 12, y: conversionArea_Y, opacity: opacity});
                    svg.append(networkArrowG);

                    networkRateTextRect = infoRect_channelTransform.use();
                    networkRateTextRect.attr({
                        x: networkPathCenterPoint.x - 12 + 20,
                        y: conversionArea_Y + 20,
                        opacity: opacity,
                        'pointer-events': 'none'
                    });
                    svg.append(networkRateTextRect);
                    networkRateText1 = svg.paper.text(networkPathCenterPoint.x - 12 + 20 + 5, conversionArea_Y + 20 + 17, '转化')
                            .attr({
                                'font-weight': font_weight_normal,
                                fill: font_fill_text,
//                                fill: font_fill_layerConversion_text,
                                'font-size': font_size_normal,
                                opacity: opacity,
                                'pointer-events': 'none'
                            });
                    networkRateText2 = svg.paper.text(networkPathCenterPoint.x - 12 + 20 + 5, conversionArea_Y + 20 + 17 + 18, networkConversionRate)
                            .attr({
                                'font-size': font_size_channelTransformValue,
                                'font-weight': font_weight_value,
                                opacity: opacity,
                                'pointer-events': 'none'
                            });

                    funnelIndexConversionG.add(networkArrowG, networkRateTextRect, networkRateText1, networkRateText2);

                    layerAnimSet.push(networkArrowG, networkRateTextRect, networkRateText1, networkRateText2);
                    channel3AnimSet.push(networkArrowG, networkRateTextRect, networkRateText1, networkRateText2);
                }

            }
        }
    }


    // 漏斗图三层图形的创建
    function createFunnel(){
        // 停止动画和隐藏元素
//        hideAllContentAndStopAnimation();
//        stopLayerAnimation();
//        if(token_interval_arrowG) {
//            clearInterval(token_interval_arrowG);
//            token_interval_arrowG = null;
//        }


        // 清空set
//        layer1AnimSet.clear();
//        layer2AnimSet.clear();
//        layer3AnimSet.clear();
//        channel1AnimSet.clear();
//        channel2AnimSet.clear();
//        channel3AnimSet.clear();
//        channel1HoverElementSet.clear();
//        channel2HoverElementSet.clear();
//        channel3HoverElementSet.clear();
        layer1AnimSet.remove();
        layer2AnimSet.remove();
        layer3AnimSet.remove();
        channel1AnimSet.remove();
        channel2AnimSet.remove();
        channel3AnimSet.remove();
        channel1HoverElementSet.remove();
        channel2HoverElementSet.remove();
        channel3HoverElementSet.remove();

        layer1Paths_arr.length = 0;   // 清空数组
        layer2Paths_arr.length = 0;
        layer3Paths_arr.length = 0;

        createChannelArea(channelsData[0], layer1AnimSet, layer1Paths_arr, colorL1Default, colorsL1Active, opacity_default, 90);
        createChannelArea(channelsData[1], layer2AnimSet, layer2Paths_arr, colorL2Default, colorsL2Active, opacity_default, 230);
        createChannelArea(channelsData[2], layer3AnimSet, layer3Paths_arr, colorL3Default, colorsL3Active, opacity_default);

        funnelIndexConversionG.appendTo(svg);
        create10086Els();
//        bindBorderHover();
//        bindChannelAnim_onMouseOver();

//        startLayerAnimation();
    }

    createFunnel();


    /**
     * 杯壁鼠标事件
     */
    function onMouseOver_LayerBorder(layerPaths_arr) {
        for (var i = 0; i < layerPaths_arr.length; i++) {
            layerPaths_arr[i].path.animate({
                fill: layerPaths_arr[i].fill_anim
            }, animDuration_default);
        }
    }

    function onMouseOut_LayerBorder(layerPaths_arr) {
        for (var i = 0; i < layerPaths_arr.length; i++) {
            layerPaths_arr[i].path.animate({
                fill: layerPaths_arr[i].fill_default
            }, animDuration_default);
        }
    }

    function onHoverIn_layer(layerAnimateSet, layerPaths_arr) {
        hideAllContentAndStopAnimation();
        stopLayerAnimation();
        layerAnimateSet.animate({
            opacity: 1
        }, animDuration_default);
        onMouseOver_LayerBorder(layerPaths_arr);
    }

    function onHoverOut_layer(layerPaths_arr) {
        hideAllContentAndStopAnimation();
        onMouseOut_LayerBorder(layerPaths_arr);
        startLayerAnimation();
    }

    /*
     ***************************** 绑定三层杯壁的鼠标移入移出的事件 *************************
     */

    function bindBorderHover(){
        pathLeftBorder1.unhover().hover(
                function () {
                    onHoverIn_layer(layer1AnimSet, layer1Paths_arr)
                },
                function () {
                    onHoverOut_layer(layer1Paths_arr)
                }
        );
        pathRightBorder1.unhover().hover(
                function () {
                    onHoverIn_layer(layer1AnimSet, layer1Paths_arr)
                },
                function () {
                    onHoverOut_layer(layer1Paths_arr)
                }
        );

        pathLeftBorder2.unhover().hover(
                function () {
                    onHoverIn_layer(layer2AnimSet, layer2Paths_arr);
                },
                function () {
                    onHoverOut_layer(layer2Paths_arr);
                }
        );
        pathRightBorder2.unhover().hover(
                function () {
                    onHoverIn_layer(layer2AnimSet, layer2Paths_arr);
                },
                function () {
                    onHoverOut_layer(layer2Paths_arr);
                }
        );

        pathLeftBorder3.unhover().hover(
                function () {
                    onHoverIn_layer(layer3AnimSet, layer3Paths_arr);
                },
                function () {
                    onHoverOut_layer(layer3Paths_arr);
                }
        );
        pathRightBorder3.unhover().hover(
                function () {
                    onHoverIn_layer(layer3AnimSet, layer3Paths_arr);
                },
                function () {
                    onHoverOut_layer(layer3Paths_arr);
                }
        );
    }



    // 总渠道转化和10086另外弄，因为位置是固定的

    /*
     **************      10086转化占比          ********************
     */

    // TODO: 逻辑上不需要重新创建
    function create10086Els(){
        var robotTo10086_path1 = svg.paper
                .path('M335,200h30')
                .attr({
                    'stroke-dasharray': "2,2",
                    stroke: font_fill_value,
                    opacity: opacity_default
                });

        var robotTo10086_path2 = svg.paper
                .path('M365,200h50v-8')
                .attr({
                    fill: 'none',
                    stroke: font_fill_text,
                    opacity: opacity_default
                });

        var robotTo10086_Title = svg.paper
                .text(360, 190, '转10086客户占比')
                .attr({
                    fill: font_fill_text,
                    'font-weight': font_weight_normal,
                    fontSize: font_size_normal,
                    opacity: opacity_default
                });


        var robotTo10086_value = svg.paper.text(410, 170, channelsData[0].to10086Rate)
                .attr({
                    'font-size': 22,
                    fill: font_fill_value,
                    'foot-weight': font_weight_value,
                    opacity: opacity_default
                });


        var onlineTo10086_path1 = svg.paper
                .path('M315,380h30')
                .attr({
                    'stroke-dasharray': "2,2",
                    stroke: font_fill_value,
                    opacity: opacity_default
                });

        var onlineTo10086_path2 = svg.paper
                .path('M345,380h50v-8')
                .attr({
                    fill: 'none',
                    stroke: font_fill_text,
                    opacity: opacity_default
                });

        var onlineTo10086_Title = svg.paper
                .text(340, 370, '转10086客户占比')
                .attr({
                    fill: font_fill_text,
                    'font-weight': font_weight_normal,
                    fontSize: font_size_normal,
                    opacity: opacity_default
                });


        var onlineTo10086_value = svg.paper.text(390, 350, channelsData[1].to10086Rate)
                .attr({
                    'font-size': 22,
                    fill: font_fill_value,
                    'foot-weight': font_weight_value,
                    opacity: opacity_default
                });

        layer2AnimSet.push(robotTo10086_path1, robotTo10086_path2, robotTo10086_Title, robotTo10086_value);
        layer3AnimSet.push(onlineTo10086_path1, onlineTo10086_path2, onlineTo10086_Title, onlineTo10086_value);

        var robotTo10086_icon;
        Snap.load("./assets/svg/iconfont-servicefill.svg", function (f) {
            robotTo10086_icon = f.selectAll("svg")[0].attr({
                x: 370,
                y: 140,
                height: 36,
                width: 36,
                'pointer-events': 'none',
                opacity: opacity_default
            });
            robotTo10086_icon.selectAll('path')[0].attr({fill: '#56abe4'});
            svg.append(robotTo10086_icon);
            layer2AnimSet.push(robotTo10086_icon);
        });

        var onlineTo10086_icon;
        Snap.load("./assets/svg/iconfont-servicefill.svg", function (f) {
            onlineTo10086_icon = f.selectAll("svg")[0].attr({
                x: 350,
                y: 320,
                height: 36,
                width: 36,
                'pointer-events': 'none',
                opacity: opacity_default
            });
            onlineTo10086_icon.selectAll('path')[0].attr({fill: '#56abe4'});
            svg.append(onlineTo10086_icon);
            layer3AnimSet.push(onlineTo10086_icon);
        });

    }


    /*
     **************      杯壁 转化箭头和数值显示 defs          ********************
     */

    var svg3_arrow_transformRate = Snap('#svg3_arrow_transformRate');

    var svg3_arrow_transformRate_1 = svg3_arrow_transformRate.use();
    svg3_arrow_transformRate_1.attr({
        x: 320,
        y: 75,
        opacity: opacity_default
    });
    svg.append(svg3_arrow_transformRate_1);

    var svg3_text_transformRate_1 = svg.paper.text(390, 120, '转化')
            .attr({
                'font-weight': font_weight_normal,
                fill: font_fill_text,
                opacity: opacity_default
            });
    var svg3_text_transformRate_2 = svg.paper.text(390, 140, channelsData[0].conversionRate)
            .attr({
                'font-weight': font_weight_value,
                'font-size': font_size_channelValue,
                fill: font_fill_value,
                opacity: opacity_default
            });


    var svg3_arrow_transformRate_2 = svg3_arrow_transformRate.use();
    svg3_arrow_transformRate_2.attr({
        x: 300,
        y: 220,
        opacity: opacity_default
    });

    svg.append(svg3_arrow_transformRate_2);

    var svg3_text_transformRate_3 = svg.paper.text(375, 265, '转化')
            .attr({
                'font-weight': font_weight_normal,
                fill: font_fill_text,
                opacity: opacity_default
            });
    var svg3_text_transformRate_4 = svg.paper.text(375, 285, channelsData[1].conversionRate)
            .attr({
                'font-weight': font_weight_value,
                'font-size': font_size_channelValue,
                fill: font_fill_value,
                opacity: opacity_default
            });

    layer1AnimSet.push(svg3_arrow_transformRate_1, svg3_text_transformRate_1, svg3_text_transformRate_2);
    layer2AnimSet.push(svg3_arrow_transformRate_2, svg3_text_transformRate_3, svg3_text_transformRate_4);


    // 层次向下流动动画

    var timeoutToken_layer1;
    var timeoutToken_layer2;
    var timeoutToken_layer3;

    // 指标层次流转
    // TODO: 变宽
    function layerFlowAnimation() {
        if (!timeoutToken_layer1) {
            timeoutToken_layer1 = setTimeout(function () {
                layer1AnimSet.animate({
                    opacity: 1
                }, animDuration_default);
                layer2AnimSet.animate({
                    opacity: 0
                }, animDuration_default);
                layer3AnimSet.animate({
                    opacity: 0
                }, animDuration_default);
                onMouseOut_LayerBorder(layer3Paths_arr);
                onMouseOver_LayerBorder(layer1Paths_arr);
                if (timeoutToken_layer1) {
                    clearTimeout(timeoutToken_layer1);
                    timeoutToken_layer1 = null;
                }
            }, 2000);
        }
        if (!timeoutToken_layer2) {
            timeoutToken_layer2 = setTimeout(function () {
                layer1AnimSet.animate({
                    opacity: 0
                }, animDuration_default);
                layer2AnimSet.animate({
                    opacity: 1
                }, animDuration_default);
                layer3AnimSet.animate({
                    opacity: 0
                }, animDuration_default);
                onMouseOut_LayerBorder(layer1Paths_arr);
                onMouseOver_LayerBorder(layer2Paths_arr);
                if (timeoutToken_layer2) {
                    clearTimeout(timeoutToken_layer2);
                    timeoutToken_layer2 = null;
                }
            }, 4000);
        }
        if (!timeoutToken_layer3) {
            timeoutToken_layer3 = setTimeout(function () {
                layer1AnimSet.animate({
                    opacity: 0
                }, animDuration_default);
                layer2AnimSet.animate({
                    opacity: 0
                }, animDuration_default);
                layer3AnimSet.animate({
                    opacity: 1
                }, animDuration_default);
                onMouseOut_LayerBorder(layer2Paths_arr);
                onMouseOver_LayerBorder(layer3Paths_arr);
                if (timeoutToken_layer3) {
                    clearTimeout(timeoutToken_layer3);
                    timeoutToken_layer3 = null;
                }
            }, 6000);
        }
    }

    // token
    var layerAnimationToken;

    /**
     * 开始层次转化动画
     */
    function startLayerAnimation() {
        if (!layerAnimationToken) {
            layerFlowAnimation();
            layerAnimationToken = setInterval(layerFlowAnimation, 8000);
        }
    }

    /**
     * 停止循环的层次转化动画
     */
    function stopLayerAnimation() {
        if (timeoutToken_layer1) {
            clearTimeout(timeoutToken_layer1);
            timeoutToken_layer1 = null;
        }
        if (timeoutToken_layer2) {
            clearTimeout(timeoutToken_layer2);
            timeoutToken_layer2 = null;
        }
        if (timeoutToken_layer3) {
            clearTimeout(timeoutToken_layer3);
            timeoutToken_layer3 = null;
        }
        if (layerAnimationToken) {
            clearInterval(layerAnimationToken);
            layerAnimationToken = null;
        }
    }


    // 隐藏所有显示的元素，并停止元素进行中的动画
    function hideAllContentAndStopAnimation() {
        // 不stop的话，鼠标从某曾杯壁移入到另一层杯壁，原来那层的杯壁的text不会隐藏
        layer1AnimSet.forEach(function (element) {
            element.stop();
        });
        layer2AnimSet.forEach(function (element) {
            element.stop();
        });
        layer3AnimSet.forEach(function (element) {
            element.stop();
        });
        layer1AnimSet.attr({opacity: 0});
        layer2AnimSet.attr({opacity: 0});
        layer3AnimSet.attr({opacity: 0});
    }
    /**
     * 创建分渠道的图标，并绑定事件，如果某分渠道没有数据，该分渠道按钮不能点击，颜色是灰
     */
    function createChannelsIcon(){
        /*
         **************      分渠道图标          ********************
         */
        var iconAPP;
        Snap.load("./assets/svg/iconfont-shouji.svg", function (f) {
            iconAPP = f.selectAll("svg")[0].attr({
                x: 80,
                y: 7,
                height: 36,
                width: 36,
                cursor: 'pointer',
                'pointer-events': 'none'
            });
            svg.append(iconAPP);
        });
        svg.paper.rect(80, 7, 36, 36).attr({fill: 'Transparent', cursor: 'pointer'}).click(iconAppClick);
        function iconAppClick() {
            flag_App = !flag_App;
            if (flag_App) {
                iconAPP.selectAll('path')[0].attr({fill: '#56abe4'});
            } else {
                iconAPP.selectAll('path')[0].attr({fill: '#999999'});
            }
            createFunnel();
            return false;
        }

        var iconWeiXin;
        Snap.load("./assets/svg/iconfont-weixin.svg", function (f) {
            iconWeiXin = f.selectAll("svg")[0].attr({
                x: 200,
                y: 7,
                height: 36,
                width: 36,
                cursor: 'pointer',
                'pointer-events': 'none'
            });
            svg.append(iconWeiXin);
        });
        svg.paper.rect(200, 7, 36, 36).attr({fill: 'Transparent', cursor: 'pointer'}).click(iconWeiXinClick);
        function iconWeiXinClick() {
            flag_WeiXin = !flag_WeiXin;
            if (flag_WeiXin) {
                iconWeiXin.selectAll('path')[0].attr({fill: '#11cd6e'});
            } else {
                iconWeiXin.selectAll('path')[0].attr({fill: '#999999'});
            }
            createFunnel();
            return false;
        }


        var iconNetwork;
        Snap.load("./assets/svg/iconfont-wangluo.svg", function (f) {
            iconNetwork = f.selectAll("svg")[0].attr({
                x: 310,
                y: 7,
                height: 36,
                width: 36,
                cursor: 'pointer',
                'pointer-events': 'none'
            });
            svg.append(iconNetwork);
        });
        svg.paper.rect(310, 7, 36, 36).attr({fill: 'Transparent', cursor: 'pointer'}).click(iconNetworkClick);
        function iconNetworkClick() {
            flag_Network = !flag_Network;
            if (flag_Network) {
                iconNetwork.selectAll('path')[0].attr({fill: '#ea8010'});
            } else {
                iconNetwork.selectAll('path')[0].attr({fill: '#999999'});
            }
            createFunnel();
            return false;
        }
    }

    createChannelsIcon();

    // 各分渠道层次流转

    // 绑定事件
    function bindChannelAnim_onMouseOver(){
        channel1HoverElementSet.forEach(function (element) {
            element.hover(function () {
                channelMouseOver(channel1AnimSet);
                if(layer1Paths_arr[0] && layer1Paths_arr[0].path){
                    layer1Paths_arr[0].path.animate({fill: layer1Paths_arr[0].fill_anim}, animDuration_default);
                }
                if(layer2Paths_arr[0] && layer2Paths_arr[0].path){
                    layer2Paths_arr[0].path.animate({fill: layer2Paths_arr[0].fill_anim}, animDuration_default);
                }
                if(layer3Paths_arr[0] && layer3Paths_arr[0].path){
                    layer3Paths_arr[0].path.animate({fill: layer3Paths_arr[0].fill_anim}, animDuration_default);
                }
            }, function () {
                channelMouseOut(channel1AnimSet);
                if(layer1Paths_arr[0] && layer1Paths_arr[0].path){
                    layer1Paths_arr[0].path.animate({fill: layer1Paths_arr[0].fill_default}, animDuration_default);
                }
                if(layer2Paths_arr[0] && layer2Paths_arr[0].path){
                    layer2Paths_arr[0].path.animate({fill: layer2Paths_arr[0].fill_default}, animDuration_default);
                }
                if(layer3Paths_arr[0] && layer3Paths_arr[0].path){
                    layer3Paths_arr[0].path.animate({fill: layer3Paths_arr[0].fill_default}, animDuration_default);
                }
            });
        });

        channel2HoverElementSet.forEach(function (element) {
            element.hover(function () {
                channelMouseOver(channel2AnimSet);
                if(layer1Paths_arr[1] && layer1Paths_arr[1].path){
                    layer1Paths_arr[1].path.animate({fill: layer1Paths_arr[1].fill_anim}, animDuration_default);
                }
                if(layer2Paths_arr[1] && layer2Paths_arr[1].path){
                    layer2Paths_arr[1].path.animate({fill: layer2Paths_arr[1].fill_anim}, animDuration_default);
                }
                if(layer3Paths_arr[1] && layer3Paths_arr[1].path){
                    layer3Paths_arr[1].path.animate({fill: layer3Paths_arr[1].fill_anim}, animDuration_default);
                }
            }, function () {
                channelMouseOut(channel2AnimSet);
                if(layer1Paths_arr[1] && layer1Paths_arr[1].path){
                    layer1Paths_arr[1].path.animate({fill: layer1Paths_arr[1].fill_default}, animDuration_default);
                }
                if(layer2Paths_arr[1] && layer2Paths_arr[1].path){
                    layer2Paths_arr[1].path.animate({fill: layer2Paths_arr[1].fill_default}, animDuration_default);
                }
                if(layer3Paths_arr[1] && layer3Paths_arr[1].path){
                    layer3Paths_arr[1].path.animate({fill: layer3Paths_arr[1].fill_default}, animDuration_default);
                }
            });
        });

        channel3HoverElementSet.forEach(function (element) {
            element.hover(function () {
                channelMouseOver(channel3AnimSet);
                if(layer1Paths_arr[2] && layer1Paths_arr[2].path){
                    layer1Paths_arr[2].path.animate({fill: layer1Paths_arr[2].fill_anim}, animDuration_default);
                }
                if(layer2Paths_arr[2] && layer2Paths_arr[2].path){
                    layer2Paths_arr[2].path.animate({fill: layer2Paths_arr[2].fill_anim}, animDuration_default);
                }
                if(layer3Paths_arr[2] && layer3Paths_arr[2].path){
                    layer3Paths_arr[2].path.animate({fill: layer3Paths_arr[2].fill_anim}, animDuration_default);
                }
            }, function () {
                channelMouseOut(channel3AnimSet);
                if(layer1Paths_arr[2] && layer1Paths_arr[2].path){
                    layer1Paths_arr[2].path.animate({fill: layer1Paths_arr[2].fill_default}, animDuration_default);
                }
                if(layer2Paths_arr[2] && layer2Paths_arr[2].path){
                    layer2Paths_arr[2].path.animate({fill: layer2Paths_arr[2].fill_default}, animDuration_default);
                }
                if(layer3Paths_arr[2] && layer3Paths_arr[2].path){
                    layer3Paths_arr[2].path.animate({fill: layer3Paths_arr[2].fill_default}, animDuration_default);
                }
            });
        });
    }

    function channelMouseOver(channelElementSet) {
        hideAllContentAndStopAnimation();
        stopLayerAnimation();
        channelElementSet.animate({
            opacity: 1
        }, animDuration_default);
    }

    function channelMouseOut(channelElementSet) {
        hideAllContentAndStopAnimation();
        startLayerAnimation();
        channelElementSet.animate({
            opacity: 0
        }, animDuration_default);
    }


    // 定时回收资源，重新初初始化（然并卵）
    function restartInterval() {
        stopLayerAnimation();
        if(token_interval_arrowG) {
            clearInterval(token_interval_arrowG);
            token_interval_arrowG = null;
        }
        var restartTimeoutToken = setTimeout(function(){
            startLayerAnimation();
            if(!token_interval_arrowG){
                token_interval_arrowG = setInterval(function () {
                    arrowAnimation(arrowG);
                }, 1050);
            }
            if(restartTimeoutToken){
                clearTimeout(restartTimeoutToken);
                restartTimeoutToken = null;
            }
        }, 5000);

    }

    //    var restartToken = setInterval('restartInterval', 30000);

</script>
</body>
</html>